; Kaypro II cpmish BIOS Â© 2019 David Given
; This file is distributable under the terms of the 2-clause BSD license.
; See COPYING.cpmish in the distribution root directory for more information.

    maclib cpm
    maclib cpmish

PORT_BITPORT equ 0
PORT_BEEPER equ 1
PORT_SERIAL_BAUD equ 2


    cseg
label BBASE

; BIOS jump table.

    jp BOOTE
    jp WBOOTE
    jp CONSTE
    jp CONINE
    jp CONOUTE
    jp LISTE
    jp PUNCHE
    jp READERE
    jp HOMEE
    jp SELDSKE
    jp SETTRKE
    jp SETSECE
    jp SETDMAE
    jp READE
    jp WRITEE
    jp LISTSTE
    jp SECTRANE




; Actual BIOS entrypoints.
;
; The BIOS calls typically use a simple calling convention where the parameter
; is in BC and the result is returned in A and HL. The docs don't mention
; anything about other registers so we'll assume they can be corrupted. In
; addition, our syscall stuff assumes that on return A = L, just like in the
; BDOS, so we have a single parameter and a single response --- all very simple.

; Cold boot on system startup.
BOOTE:
    ; set up a stack, which we only need for printing the version
    ld sp, 0x0100            ; ephemeral startup stack

    ; print the banner
    call print
    cpmish_banner 'ESP32 Emulator'
    db 0

    ; clear the IOBYTE and the DISK
    xor a
    ld (IOBYTE), a
    ld (CDISK), a


; Warm boot on application exit.
WBOOTE:
    ; tell the emulator to reload the CCP/BDOS/BIOS image into
    ; memory from other storage.  On initial startup, it will get loaded 
    ; by the emulator and then we fall through from BOOTE and load
    ; it again. Inefficient, but not really worried.  On warm boot the
    ; image gets loaded on top the existing one so it's not a problem
    ; if it's exactly the same.  Could be interesting if it isnt.
    ; This also will initialize the Disk Paramter Tables based on the
    ; configuraiton of the emulator
    out (1), a

    ; set things up to call the CCP
    ld a, 0xc3
    ld hl, BBASE + 3         ; init BIOS entrypoint
    ld (0x0000), a
    ld (0x0001), hl

    ld hl, FBASE + 6         ; init BDOS entrypoint
    ld (0x0005), a
    ld (0x0006), hl

    ld a, (CDISK)            ; current selected disk
    ld c, a
    jp CBASE                 ; pass control to CCP

; The rest of the BIOS calls all just call the emulator and return
; this macro simplifies it.
call_em macro FN
	out (FN), a
	or a
	ret
    endm

CONSTE:
    call_em(2)

CONINE:
    call_em(3)

CONOUTE:
    call_em(4)

LISTE:
    call_em(5)

PUNCHE:
    call_em(6)

LISTSTE:
    call_em(7)

READERE:
    call_em(8)

; Selects a drive, returning the address of the DPH in HL (or 0x0000 on
; error).
SELDSKE:
    call_em(9)

HOMEE:
    call_em(10)

SETTRKE:
    call_em(11)

SETSECE:
    call_em(12)

SETDMAE:
    call_em(13)

READE:
    call_em(14)

WRITEE:
    call_em(15)

SECTRANE:
    call_em(16)

; Disk parameter tables.  Let's assume that the emulator
; can have up to 4 disks.  The tables will be filled
; in by the emulator.  This is the disk parameter header 
DPBASE:
    dw 0, 0, 0, 0, DIRBF, DPBLK0, CHK00, ALL00
    dw 0, 0, 0, 0, DIRBF, DPBLK1, CHK01, ALL01
    dw 0, 0, 0, 0, DIRBF, DPBLK2, CHK02, ALL02
    dw 0, 0, 0, 0, DIRBF, DPBLK3, CHK03, ALL03

; scratch directory area
DIRBF: ds 128

; disk parameter blocks
DPBLK0: ds 15
DPBLK1: ds 15
DPBLK2: ds 15
DPBLK3: ds 15

; check vectors
CHK00: ds 16
CHK01: ds 16
CHK02: ds 16
CHK03: ds 16

; allocation vectors
ALL00: ds 31
ALL01: ds 31
ALL02: ds 31
ALL03: ds 31



; Prints the text immediately following the call to print.
print:
    pop hl                   ; return address points to text to print
    ld a, (hl)
    inc hl
    push hl                  ; save address after current char

    or a
    ret z                    ; if byte was zero, return
    ld c, a
    call CONOUTE
    jr print

