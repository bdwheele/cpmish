; Brother WP2450DS cpmish BIOS Â© 2019 David Given
; This file is distributable under the terms of the 2-clause BSD license.
; See COPYING.cpmish in the distribution root directory for more information.

; This is the executable which is loaded and run by the Brother's OS. It
; gets loaded at 0x8000 with BBR=0x20, CBR=0x61 and CBAR=0x88. This puts
; common 1 at logical 0x8000, physical 0x69000.

    maclib cpmish
    maclib cpm
    maclib brotherpowernote
    maclib addresses

    extrn FDBUF
    extrn FDCAL2
    extrn FDDEBLK
    extrn FDINIT
    extrn FDR512
    extrn FDRECAL
    extrn FDRSTAT
    extrn FDTX
    extrn FDSTAT
    
    extrn TTYINIT
    extrn TTYPUTC
    extrn TTYPUT8
    extrn TTYPUT16
    extrn TTYPUTSI
    extrn TTYGOTO

    public ADDAHL

    org 0x8000
start:
    dw 0xc185           ; Brother magic numbers
    dw 0x0201
    dw 0x0000
    db "BR"

    di
    ld a, 0x61
    out0 (BBR), a
    ld a, 0xf8
    out0 (CBAR), a
    ei

    di                  ; The Brother OS is not at home.

    call TTYINIT

    call TTYPUTSI
    db "Boot loader!", 13, 10, 0

scan_keys:
    ld c, 8                     ; column
    ld hl, keyboard_bitmap

keyboard_column_loop:
    out0 (PORT_KEYBOARD), c

    ld a, 0x80
.1
    dec a
    jr nz, .1

    in0 d, (PORT_KEYBOARD)
    ld a, d
    xor (hl)                    ; find which keys have changed
;    jr z, no_keys_pressed

    ; Some keys have changed.

    ld (hl), d                  ; update bitmap
    ld b, 7                     ; row
.2:
    rlca                        ; has this key changed?
    call c, key_up_down
    rlc d
    dec b
    jp p, .2
;no_keys_pressed:

    inc hl
    dec c
    jp p, keyboard_column_loop
    jr scan_keys

    ; Motor on.

    ld a, 00011100b
    out0 (PORT_765_OPERATIONS), a

    ; Seek.

    ld b, fdc_seek_end - fdc_seek
    ld hl, fdc_seek
    call send_command
    call wait_for_command_end

    call TTYPUTSI
    db "done seek", 13, 10, 0

    ; Issue FDC command.

    ld b, fdc_read.end - fdc_read
    ld hl, fdc_read
    call send_command

    ; Configure DMA.

    ld b, fdc_dma.end - fdc_dma
    ld hl, fdc_dma
    ld c, MAR1L
    otimr

    ; Perform transfer.


    ld a, 00010000b
    out0 (CNTLA1), a
    in0 a, (DCNTL)
    and 0xf0
    or 0x0a
    out0 (DCNTL), a
    ld a, 10010000b
    out0 (DSTAT), a

    call wait_for_command_end

    ld a, 00010000b
    out0 (DSTAT), a

    call TTYPUTSI
    db "done read", 13, 10, 0

    call read_status
    ld a, (data.fd765_status+0)
    call print_a
    ld a, (data.fd765_status+1)
    call print_a
    call TTYPUTSI
    db 13, 10, 0
    
    ld hl, buffer
    ld bc, 0x20
print_loop:
    ld a, (hl)
    inc hl
    dec bc

    push hl
    push bc
    call TTYPUT8
    ld a, ' '
    call TTYPUTC
    pop bc
    pop hl

    ld a, b
    or c
    jr nz, print_loop

.1
    jr .1

wait_for_fdc_writable:
    in a, (PORT_765_STATUS)
    rla
    jr nc, wait_for_fdc_writable
    ret

read_status:
    push hl
	ld hl, data.fd765_status
read_status_loop:
    in a, (PORT_765_STATUS)
	rla							; RQM...
	jr nc, read_status_loop		; ...low, keep waiting 
	rla							; DIO...
	jr nc, .1	        		; ...low, no more data
    in a, (PORT_765_DATA)
	ld (hl), a
	inc hl
	jr read_status_loop
.1
    pop hl
    ret
data.fd765_status:
	ds 8						; 8 bytes of status data

wait_for_command_end:
    in a, (PORT_DISK_STATUS)
    and DISK_STATUS_BUSY
    jr z, wait_for_command_end
    ret

print_a:
    push af
    push bc
    push de
    push hl
    call TTYPUT8
    ld a, ' '
    call TTYPUTC
    pop hl
    pop de
    pop bc
    pop af
    ret

; Command ptr in HL, length in B.
send_command:
    call wait_for_fdc_writable
    ld c, PORT_765_DATA
    outi
    jr nz, send_command
    ret

; b: row
; c: column
; d bit 7: key state

key_up_down:
    push af
    push bc
    push de
    push hl

    ld a, c
    add a
    add a
    add a
    or b        ; a = keycode
    rla
    ccf
    rl d
    rra
    call print_a

    pop hl
    pop de
    pop bc
    pop af
    ret

ADDAHL:
    add a, l
    ld l, a
    ret nc
    inc h
    ret

fdc_seek:
    db 0x0f     ; 0: SEEK
    db 0        ; 1: drive 0
    db 0        ; 2: track 0
fdc_seek_end:

fdc_read:
    db 0x66     ; 0: READ SECTORS
    db 0        ; 1: physical head 0, drive 0
    db 0        ; 2: track 0
    db 0        ; 3: logical head 0
    db 1        ; 4: first sector
    db 2        ; 5: bytes per sector: 512
    db 1        ; 6: last sector (*inclusive*)
    db 27       ; 7: gap 3 length (27 is standard for 3.5" drives)
    db 0        ; 8: sector length (unused)
fdc_read.end:
  
fdc_dma:
    dw buffer+0x1000    ; MAR1 low
    db 0x06             ; MAR1 high
    dw 0x86             ; IAR1
    db 0                ; unused
    dw 0x200            ; BCR1
fdc_dma.end:

buffer: ds 512, 0x55
keyboard_bitmap: ds 8*9, 0xff
