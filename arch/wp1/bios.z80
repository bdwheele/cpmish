; Brother WP1 cpmish BIOS Â© 2022 David Given
; This file is distributable under the terms of the 2-clause BSD license.
; See COPYING.cpmish in the distribution root directory for more information.

    maclib cpm
    maclib cpmish
    maclib brotherwp1
    maclib addresses

    public SYSIN
    public SYSOUT
    public ADDAHL

    extrn SELDSKE
    extrn HOMEE
    extrn SETTRKE
    extrn SETSECE
    extrn SETDMAE
    extrn READE
    extrn WRITEE
    extrn SECTRANE

    extrn TTYINIT
    extrn TTYPUTC
    extrn TTYPUT8
    extrn TTYPUT16
    extrn TTYPUTSI
    extrn CURSTOGG

    cseg

; BIOS jump table.

    jp BOOTE
    jp WBOOTE
    jp CONSTE
    jp CONINE
    jp CONOUTE
    jp LISTE
    jp PUNCHE
    jp READERE
    jp HOMEE
    jp SELDSKE
    jp SETTRKE
    jp SETSECE
    jp SETDMAE
    jp READE
    jp WRITEE
    jp LISTSTE
    jp SECTRANE

; Actual BIOS entrypoints.
;
; The BIOS calls typically use a simple calling convention where the parameter
; is in BC and the result is returned in A and HL. The other registers can be
; corrupted *except* for ix, which ZSDOS requires to be preserved; without it
; it goes all funny and disk accesses fail weirdly. Eight-bit values are
; returned in A and sixteen-bit values in HL.

; Cold boot on system startup.
BOOTE:
    di
    ld sp, 0x0100           ; ephemeral user stack
    ld c, 0xe0              ; map RAM in everywhere
    out0c CBAR

    call TTYINIT
    call TTYPUTSI
    db 13, 10
    cpmish_banner "Brother WP1"
    db 0

    xor a
    ld (IOBYTE), a          ; reset iobyte and current disk
    ld (CDISK), a

    ; fall through
; Warm boot on application exit.
WBOOTE:
    ld sp, 0x0100           ; ephemeral user stack

    ; Reload the CCP (but not the BDOS or CCP).

    call SYSIN

    ld bc, 14           ; sector number; offset $d00
    ld hl, $f800        ; temp buffer
    ld e, (BDOS_SIZE+CCP_SIZE)/256 ; number of sectors
    ld d, CBASE/256 + $70 ; page of destination address (relative to $20000)
loadloop:
    push bc
    push de
    push hl
    ld a, 6             ; read sector
    rst $28

    pop hl
    pop de
    pop bc

    ; DMA the read sector out of the temporary buffer and into user RAM.

    xor a
    out0a SAR0L         ; SAR0 = temp buffer phys @ 0x25800
    ld a, $58
    out0a SAR0H
    ld a, $02
    out0a SAR0B

    xor a
    out0a DAR0L         ; DAR0 = target phys @ 0x2xx00
    ld a, d
    out0a DAR0H
    ld a, $02
    out0a DAR0B

    xor a               ; BCR0 = 0x100, one sector
    out0a BCR0L
    inc a
    out0a BCR0H

    ld a, 2             ; start DMA
    out0a DMODE
    ld a, $40
    out0a DSTAT
    
    inc bc              ; advance to next sector
    inc d               ; ...and next address
    dec e               ; ...reduce count
    jr nz, loadloop

    call SYSOUT
    ; fall through
call_ccp:
    ld a, 0xc3
    ld hl, BBASE + 3         ; init BIOS entrypoint
    ld (0x0000), a
    ld (0x0001), hl

    ld hl, FBASE + 6         ; init BDOS entrypoint
    ld (0x0005), a
    ld (0x0006), hl

    ld a, (CDISK)
    ld c, a                  ; c = current disk
    jp CBASE                 ; pass control to CCP

stop_disk_motor:
    call SYSIN
    ld a, 2                  ; finished with disk
    rst 0x28
    call SYSOUT
    ret

CONSTE:
    ld hl, disk_off_count
    inc (hl)                 ; increment drive motor count and...
    call z, stop_disk_motor  ; ...turn the motor off on rollover

    xor a
    ret

CONINE:
;    call CURSTOGG
;    call SYSIN
;    ld a, 6                  ; finished with disk
;    rst 0x28
;.1
;    ld a, 9                  ; get a raw key scancode
;    rst 8
;    jr nc, .1
;    call SYSOUT
;    call CURSTOGG
;
;    ld a, d
;    and 0x3f
;    bit 7, d
;    jr z, .2
;    add 0x40
;.2
;    ld hl, keyboard_table
;    call ADDAHL
;    ld a, (hl)
;    or a
;    bit 7, a
;    jr nz, .4
;
;    bit 6, d                ; CODE pressed?
;    jr z, .3
;    bit 6, a                ; 0x40 or up?
;    jr z, .3
;    and ~0x20
;    sub 0x40
;.3
;    ret
;.4
;    call SYSIN
;    rst 0

ADDAHL:
    add a, l
    ld l, a
    ret nc
    inc h
    ret

CONOUTE:
    ld a, c
    jp TTYPUTC

LISTE:
PUNCHE:
    ret

LISTSTE:
READERE:
return_error:
    ld a, 0xff
    ret

; Switch from CP/M mapping to Brother OS mapping, with the BIOS at the top of
; memory.  DO NOT TAIL CALL THIS.

SYSIN:
    exx
    pop hl                  ; return address
    ld (saved_stack), sp    ; save the CP/M stack pointer
    ld c, 0xe7              ; expose the Brother ROM
    out0c CBAR
    ld sp, 0x0000           ; switch to the Brother stack
    push hl
    exx
    ei
    ret                     ; exit

; Switch from the Brother OS mapping to the CP/M mapping.
; DO NOT TAIL CALL THIS.

SYSOUT:
    di
    exx
    pop hl                  ; return address
    ld c, 0xe0              ; map RAM in everywhere
    out0c CBAR
    ld sp, (saved_stack)
    push hl
    exx
    ret

saved_stack: dw 0            ; user stack pointer while in system calls
disk_off_count: db 0         ; cheap and nasty drive motor timer

; vim: ts=4 sw=4 expandtab ft=asm

